快捷键重映射
======
``` vim
map {lhs} {rhs}
map 快捷键 相当于按下的键序列
```


特殊键表示
-----
* \<SID> 当映射命令用于脚本文件中（应该经常是这种情况），\<SID> 用于指代当前
  脚本作用域的函数，故一般用于 {rhs} 部分。当 vim 执行映射命令时，实际会把
  \<SID> 替换为 \<SNR>dd_ 样式，其中 dd 表示当前脚本编号，可用 :scriptnames
  查看所有已加载的脚本，同时也列出每个脚本的编号。

* \<Plug> 一种特殊标记，可以避免与用户能从键盘输入的任何按键冲突。常用于插件
  中，表示该映射来自某插件。与 \<SID> 关联某一特定脚本不同，\<Plug> 并不关联
  特定插件的脚本文件。

* `:<C-u>` 并不是什么特殊语法，只不过表示当按下冒号刚进入行时先按个 \<C-u>，
  用以先清空当前命令行，确保在执行后面那个命令时不会被其他可能的命令行字符干扰。
  （比如若不用 nnoremap 而用 noremap 时，在可视模式选了一部分文本后，按冒号
  就会自己加成 :'<,'>，此时在命令行中先按 \<C-u> 就能把前面的地址标记清除。在
  很小心地用了 nnoremap 时，还会不会有情况情况导致干扰字符呢，也不好说，反正加
  上 \<C-u> 没坏处。但若你的函数本就设计为允许接收行地址参数，则最好额外定义
  :vnoremap，不用 \<C-u> 的版本。
* \<buffer> 表示只影响当前 buffer 的映射，`:map` `:unmap` 与 `:mapclear` 都可
  接收这个局部参数。
* \<nowait> 字面意思是不再等待。较短的局部映射将掩盖较长的全局映射。

表达式映射
-----
``` vim
: nnoremap \j @="Jj"<CR>
: nnoremap <expr> \j "Jj"
```
* `=`: 表达式寄存器, 插入模式用`<C-R>` 调用寄存器, 普通模式用`@`调用寄存器.

命令后缀映射(Operator-pending)
-----------
``` vim
:onoremap q i"
:nnoremap {lhs} :set operatorfunc=OperaFunc<CR>g@
```
> 命令后缀映射的机制，对于 :onoremap {lhs} {rhs} 映射。首先将 {rhs} 当
作普通模式下命令（按键序列）执行。如果执行后 vim 仍在普通模式下，且移动了光标
，则将前后两个时刻的光标位置之间的区域当作文本对象。如果执行后在可视模式，则将
选择部分的文本当作文本对象。内置命令 dw dp 类似前一种情况，而 da( di(
类似后一种情况。

todo: 如何自定义操作符呢?
